Topic Covered and Questions solved in each file name

Hello.c revision
sum of first natural number
check prime using c



second.cpp

//c++ basic, if-else, for loop
// data types
// type casting
// vowels and consonant
// to print alphabets
// print numbers with digit difference 3
// to calculate the power
// sum of n natural number
// is prime
//  Fibonacci series


third.cpp


// Pattern Printing

// row number pattern
// column number pattern
// reverse column number pattern
// column square number pattern
// row alphabet pattern
// col alphabet pattern
// number print with increment
// left pyramid
// number left pyramid pattern
// character left pyramid pattern
// reverse star
// number upper left pyramid
// number left pyramid
// right pyramid
// right number half pyramid
// reverse number count right pyramid
// number count right pyramid
// alphabets pattern
// pyramid
// pattern print//palindrome
// reverse pyramid star
// special patterns
// double triangle butterfly
// rhombus




fourth.cpp



// bitwise operator
// pre and post increment
// sum of n natural number using do while loop
// decimal to binary conversion
// binary to decimal
// binary to octal
// dec to hexadecimal


fifth.cpp

// all basic logic is made in this
// sum of digits
//single digit sum
// leap year
// Reverse Integer
// if a number is power of 2 then yes else no
// to print square root of a number
// square root function from mathc
// palindrome in case of number 
// complement of a number



sixth.cpp

// swap
// string operation
//capitalize character
// Armstrong number
// find trailing zero in factorial:
// to check whether we can make rectangle or not out of four sides given
//  Bishop problem Enter the row and column position of bishop, count bishops move
// loose when i am initiator and winning number has 4 as factor.//we have to move 3 steps , we try to catch the remaining number factor of 4.but opponent has power.

Seventh.cpp


// Addressing and indexing, search in array and its memory allocation
// reverse array
// reverse the array in its own place without extra array
// missing number
// second mac number
// find nth position element in Fibonacci series using an array.
// rotate array



eight.cpp

time complexity




ninth

// bubble sort.
//Insertion sort
// Selection sort

// binary search


// search in rotated array
// to find the min element in the rotated array
// Peak index in mountain


// book Allocation//such that number of pages difference should be minimum
// painter Partition
// ship Package



// max value
// min value
// Aggressive cow problem.//sorted and unsorted array
// banana problem   // k is the hours we have to distribute this bananas such that if we finish we move to next index bananas



//vector




tenth.cpp

//pointer


eleven.cpp


// Prefix Sum
// Subarray
// Divide array in Subarray with equal sum
// largest sum subarray
// Max Difference when bigger element at right side and smaller in left



twelve.cpp

// Trap Rain on building
// sum of 3 subarray element equals the target
// sum of 4 subarray element equals the target


thirteen.cpp

// print2D
// add Matrix
// row Index with Max Sum
// diagonal Sum
// reverse Row



fourteen.cpp

// column major order.
// row major order
// 2D vector
// Wave form
// spiral form
// Transpose Matrix


fifteen.cpp

// Rotate by 90 degree//also called rotate image by 90 degree as image is points in matrix form hence it can be taken in that way
// rotate matrix k times//each time 90 deg is rotated


sixteeth.cpp

// Binary Search in 2D
// Search in sorted row and sorted column but whole not sorted.
// binary search in decreasing order array



seventeenth.cpp

// store 2 values at one place.
// using modulus and division effectively

// find missing and repeating element
// find the occurrences of number
// Majority Element.



18

// all string function and theory
// reverse string
// find size of string
// to check whether a string is palindrome or not


19

// Defanging an IP address
// clockwise//right rotation
// anti clock wise// left rotation
// Pangram
// sort a string using count sort


20
// longest palindrome
// Sorting the sentence
// sort vowel in a string
// sum of string // '23'+'549999'='77'


21

// Roman to integer
// integer to roman
// factorial of a number
// longest subset without repeating character.
// sliding window protocol //solves in O(N) or O(2N)
// Smallest Distinct Window

22

// KMP Algorithm || Longest Prefix Suffix

// string Matching Algorithm

//  Knuth-Morris-Pratt Algorithm

// Naive string matching algorithm

// KMP string matching algorithm

// Make a string Palindrome.//by adding characters only at start.

// Circular pattern matching

23
// Pointer in C++

// pointer in array
// pointer in char

// pass by pointer

// pass by pointer

// Note: for simplicity use the following only in preferred way
// for vect, string - reference helps using & in function
// for int arr, char - pointer helps.

24
// Double Pointer and Multiple Pointers in C++

25
// dynamic memory location in heap using new keyword.
// try to read from right to left for easy visualization
// 1D array dynamic memory allocation
// 2D array with the help of pointer
// 3D array in heap. here we need to create many 2D array to form 3D array.



26
// Recursion
// always try to make base case that you know, from bigger to larger.
// In recursion just solve for one case , it will automatically solve for others

// number print
// even number
// factorial
// sum of n natural num
// power of number
// sum of square of number
// find 8th index value in Fibonacci series
// Nth Stair problem//we have to give the total number of ways in answer. to ho on nth satair with either 1step or two step at a time.
// print array elements
// find array sum
// fin min and max element using recursion

// Recursion on string
// find palindrome
// count vowels
// reverse the string
// Capitalize



27


// linear search
// binary search

// time complexity in recursion
// For time complexity, calculate the total node formed . for space complexity find the height of tree.
// when array is passed in parameter then it is taken as pointer and only 4 bytes is take by it in every call.
// when vector is passed then it's copy is made, hence it take n size in every call.
// when &vector passed then it is used as reference and take constant time

// // merge sort//O(nlogn) //divide and merge.
// max space when this large merge is called can be imagined.
// Space complexity: O(n)

// merge sort


28
// set//subset//powerset//subsequence set//all same
// subsequence for "abc"
// generate parenthesis
// Subset Sum
// Target Sum
// Perfect Sum Problem
// Target sum repetition


29

// Find all the permutation
// find distinct permutation when duplicate values present.
// ways to Sum N. //I think I have done such question already
// new branch is evaluated as it itself is parent in forward, then combine with ans+= new branch ans at the time of backtrack //



30

// Tower Of Hanoi
// Predict the winner
// Josephus Problem || Predict the winner//Recursion me pattern nahi banta toh khud se banana aana chahiye
// Rat in a Maze//recursion on 2D array//Find all direction path
// N bit binary Number //find all n bits binary number where number of 1 is more than 0 in any prefix.




31

// OOPs concept
// Classes are datatype defined by user. //variable with this datatype is called object.
// Class has both attributes and functions.
// Attributes are variable declared .
// classes are also called blueprint for object.
// alignment and padding
// static vs Dynamic Memory allocation



32

//constructor

// When object is made , it is not initialized with any value hence we need to set it with constructor for good coding.
// It is necessary to initialize for creating a good object.
// as same name hence , it points to the nearest scope value hence both points to parameter not the attribute.
// here in this case it creates new space by itself and this value is put there, not valid.
// to solve this problem , we use this pointer which points to object
// this stores object address. means this is a pointer. Hence we can access like a pointer.
// now this is sending the address. hence it points to attribute.

// constructor is called every time by itself//this is by default same value for every object. hence we use constructor initializer.



33


// static data
// static member function.
// const keyword.//not update the data
// Encapsulation
// Abstraction
// access modifier public, protected, private
// Inheritance
// // types of inheritance
// single inheritance(one parent one child)eg Human and student.

// first parent constructor is called.
// destructor is from child to parent.

// multilevel inheritance

// multiple inheritance
// hierarchical inheritance
// hybrid inheritance
// Multipath Inheritance

//
// Polymorphism
//
// function overloading

//
// const keyword in C++ enforces immutability//, ensuring that a variable, pointer, reference, or member function cannot modify certain data. It is a powerful tool for:
// Safety: Preventing accidental modifications.
// Clarity: Expressing design intent (e.g., "this value should not change").
// Optimization: Enabling compiler optimizations.
//



34
// Exception handling//handle unexpected problem


35
// file stream

// we want same file to have read write and save in secondary memory
// if we want to read, then we need to take a file from secondary to ram then read it.
// I we want to write then create or bring a file to ram and write into the file and then save to Secondary memory

// ifstream//input file stream//read the input file in form of stream
// ofstream//output file stream to write in file as output.
// ofstream and ifstream is a class of fstream.

// ofstream and ifstream have many function defined inside,like open, hence to use this class . we need to make object of this class file then use different function.



36
// LinkedList
// static without new node
// dynamic with new node


37

// deleting the first node in LinkedList takes O(1)
// to come back, we need to use LinkedList
// Even tail pointer will not help.

38

// LinkedList
// print the LinkedList
// insertAtIndex
// InsertAtEnd
// DeleteAtIndexRecursion
// reverseLinkList
// reverseLinkListWithTwoPointer
// reverseLinkedListRecursion
// middle Element
// pseudo pointer to find Middle of LinkedList
// rotate list by k
// Remove Nth Node from end
// Solve using two pointer to remove N end 
// to delete every k node
// Check Palindrome
// check palindrome using vector
// check palindrome by reversing after middle
// Remove Duplicate using vector
// Remove duplicate in place and effectively
// merge two sorted List
// to solve it in place without extra LinkedList creation
// Sorting the linked list with only 0, 1,2 value present
// Sorting the linked list with only 0, 1,2 value present //along with it's address



39

// Double linked list is used in UNDO and REDO operation, where each node contains the current time data, then it moves to next node to fill the all chages+old.

// there is a current pointer which traverse over the double linked list. If UNDO , then it displays the content of prev, In case of REDO, next pointer works.

// INSERT
// DELETE
// Remove Duplicate


40
// Circular linked list.
// insert at given index

// in circular LinkedList loop related question is asked.
// detect loop in the LinkedList.

//  // we can use map(dictionary) also where instead index, we used the name of the data and then put it's corresponding value

//  Floyd's Cycle-Finding Algorithm to detect and remove a loop

// Intersection in Y shaped LinkedList

// need to be solved
// Add two numbers

// multiply two numbers

// reverse a LinkedList ingroup of size

// flattening a LinkedList
// we thought of one more way where when greater in bottom is found then , it's right position is founded.

// Merge K Sorted LinkedList
// use merge sort for merging K sorted LinkedList.

// make clone of LinkedList with next and random pointer




41

// stack
// insertion and deletion only at one end.

// stack is an abstract data based on user requirement.
// It uses LIFO principle
// Operation. push, pop, top(pointer point the last index or top of stack, size, peek(data at top ) function

// Stack implementation using STL : standard template library



// problems that can be solved using stack

// reverse the array
// Insert at bottom
// make the array beautiful,  we have to remove the adjacent +ve and -ve value together.
// here as we need to store the history of last neighbor after pop, hence we can use stack for storing the history , which will be needed again.
// same adjacent string is removed
// parenthesis is valid or not //O(n) time complexity and O(n) space complexity.//for O(1) space complexity , we use count of left and right
// minimum add to make valid
// valid parenthesis with  different types of brackets
// background string Compare //if # comes then remove the last character, it means # means backspace and backspace removes the last character.
// print bracket number
// Get Minimum at pop




42.


// next greater element right
// next smallest element right
// next greater element left
// next smallest element left
// Next greater element 2

// for below problems, we need count approach/range/as group of numbers asked
// Stock Span Problem
// largest rectangle in histogram
// minimal rectangle in 2D
// the celebrity Problem
// push, pop, getmin in O(1)
// maximum of minimum from every window size
// minimum of maximum from every window size //do later
// implement two stack in an array
// implement N stack in an array

43

// FIFO //Queue

// circular implementation of queue using array
// implementation of queue using LinkedList
// inbuilt STL queue

// Print all the element in queue
// queue reversal using stack is good option



44

// calculate the time needed to get all tickets
// implement queue using stack.
// implement stack using queue.
// print all number in every window of size k
// first negative integer in every window of size k.//two methods
// first no repeating char in a stream of characters//two method



45

// Double ended queue
// inbuilt stack and queue is implemented with Dequeue

// Dequeue with LinkedList
// Dequeue with array
// stack using deque inbuilt

// Sliding window maximum.
// Minimum Number of K consecutive Flip bits //two methods



46

// Create tree level wise and side wise and using recursion
// In order, preorder, post order traversal
// level wise traversal
// binary size
// binary sum
// Count leaf's in binary tree
// Count non leaf's in binary tree
// height of binary tree
// largest value in each level
// two tree are identical
// Mirror tree
// Check for balance tree
// level order traversal in spiral form




47


// Check if two nodes are cousin//nodes having same grandparent
// left view of binary tree using queue
// left view of binary tree using recursion
// right view of binary tree
// top view
// bottom view

// traversal of tree using iteration not recursion
// preorder
// post order
// in order//complex

// Construct a tree from In order and preorder
// form tree from pre + in
// form tree from post + in
// check validity of tree

// Vertical Traversal of Binary Tree
// Diagonal traversal of binary tree
// boundary traversal

// Morris traversal
// In order using Morris in O(1) space
// Preorder
// Post order

// flatten Binary to linked list

// burning tree
// Max path Sum between two special Nodes with only one connection



48


// BST

// create BST from user input.// for now we are creating using array
//  method 2 using recursion
// deleting a node
// or method using swap to delete the node
// Check BST
// we can use in order traversal.
// we can remove the space complexity of storing in order traverse value as we need only left node to compare
// Minimum distance between any two nodes in BST
// sum of k smallest elements in BST
// Kth largest Element in BST

// Array to balance BST
// Construct BST from preorder traversal
// Construct BST from post order traversal
// Preorder and BST
// check if a BST can be created with preorder
// lowest common ancestor in a BST
// Print BST element in given range
// Check whether BST contains Dead End
// Common Node in two BST
// Merge two BST



49.
STL-


//list
// SET
// UNORDERED SET
// MAP
//multimap


50

// Zero Sum subarray(brute force method, then use prefix sum)
// Subarray Sum equals K
// Subarray Sums divisible by K
// Subarray product less than K
// Subarray product of sum and it's length less than K
// Minimum size Subarray Sum greater or equal to the target.
// Minimum window Substring
// Length of longest subarray with at most K frequency
// Count Subarray where max element appear at least K times
// Subarray with K different Integer



51

// heap implementation, insert, delete, built from array, sort it, traverse
// Priority Queue
// height of a heap , edges height count
// Minimum cost of Ropes
// Magician and Chocolates
// Last Stone Weight
// Take gift from richest pile
// profit maximization
// Kth Smallest Element
// Kth Largest Element
// Sum of elements between k1 and k2 smallest.
// Kth largest element in a stream
// Merge two binary max heap
// is binary tree heap
// level order traversal in spiral form using stack(2 stacks)  not vector or queue
// merge K sorted LinkedList to get new sorted linked list



52

// Graph
// undirected Graph Adjacency matrix(using class)
// Directed Graph Adjacency matrix(by asking every edge weight from user at run time)
// Adjacency list
// Deleting a node in Adjacency list
// BFS traversal
// DFS traversal
// topological sort (DAG- Directed acyclic graph) using DFS
// topological sort (DAG- Directed acyclic graph) using BFS //Kahn's algorithm
// Cycle detection in undirected graph
// detect cycle in directed graph dfs
// cycle detection using BFS // Kahn's Algorithm for topological sort
// Bipartite Graph (using BFS)
// Bipartite Graph (using DFS)



53
// Covid spread
// simplified Covid spread
// find the number of island
// Replace all O's or a group of 'O with X's that are surrounded by 'X
// prerequisite tasks
// Alien DICTIONARY
// parallel course
// Shortest path distance in undirected non weight graph
// Shortest path node sequence in undirected non weighted graph
// Shortest path dist from src in directed acyclic graph
// Dijkstra's Algorithm (3 ways)
// using queue, using for loop, using priority queue
// Shortest path node sequence in weighted undirected graph



54
// bellman Ford Algorithm
// Floyd Watshall Algorithm
// Shortest source to destination path
// knight walk
// find whether path exist
// Eular path and Eular circuit on the bases on connected and indegree count
// Circle of string
//


55

// N queen placement
// M coloring problem
// Sudoku Solver

// N queen placement
// placing N queens on N*N chessboard



56

// min number of coins
// shop in candy Store
// Assign Mice to holes
// Min Rotation to unlock a circular Lock
// N meeting in a room




57

// Job scheduling
// Single threaded CPU
// fractional knapsack
// Non overlapping Intervals
// Insert Interval
// Task Schedular


58.

// Security
// Huffman coding
// hashing
// Separate Chaining: Uses linked lists for each bucket
// Linear Probing: Simple collision resolution by checking next slot
// Quadratic Probing: Uses quadratic function for probe sequence
// Double Hashing: Uses second hash function for step size
// Password Hashing: Multiple hash generation methods
// Encryption/Decryption: Simple cryptographic techniques


59.


// for each below
// using recursion
// top down approach
// bottom up approach
// space optimization for this approach


// Fibonacci series n th value

// Climbing Stairs
// Number of Hops
// min cost Climbing Stair
// House Robbery
// House Robber 2
